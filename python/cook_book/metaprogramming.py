# 1. Putting a Wrapper Around a Function
# 2. Preserving Function Metadata When Writing Decorators
# 3. Unwrapping a Decorator
# 4. Defining a Decorator That Takes Arguments
# 5. Defining a Decorator with User Adjustable Attributes
# 6. Defining a Decorator That Takes an Optional Argument
# 7. Enforcing Type Checking on a Function Using a Decorator
# 8. Defining Decorators As Part of a Class
# 9. Defining Decorators As Classes
# 10. Applying Decorators to Class and Static Methods
# 11. Writing Decorators That Add Arguments to Wrapped Functions
# 12. Using Decorators to Patch Class Definitions
# 13. Using a Metaclass to Control Instance Creation
# 14. Capturing Class Attribute Definition Order
# 15. Defining a Metaclass That Takes Optional Arguments
# 16. Enforcing an Argument Signature on *args and **kwargs
# 17. Enforcing Coding Conventions in Classes
# 18. Defining Classes Programmatically
# 19. Initializing Class Members at Definition Time
# 20. Implementing Multiple Dispatch with Function Annotations
# 21. Avoiding Repetitive Property Methods
# 22. Defining Context Managers the Easy Way
# 23. Executing Code with Local Side Effects
# 24. Parsing and Analyzing Python Source
# 25. Disassembling Python Byte Code





